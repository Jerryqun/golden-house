JavaScript中一切引用类型都是对象，对象就是属性的集合
Array类型、Function类型、Object类型、Date类型、RegExp类型等都是引用类型
1、原型
每一个对象从被创建开始就和另一个对象关联，从另一个对象上继承其属性，这个另一个对象就是 原型
隐式原型（__proto__）引用类型都有自己的隐式原型
显示原型（prototype）

const obj = {};
const arr = [];
const fn = function() {}

console.log('obj.__proto__', obj.__proto__);  Object
console.log('arr.__proto__', arr.__proto__);  Array
console.log('fn.__proto__', fn.__proto__);    Function

const P = new fn()


Object.getPrototypeOf(P) ===  P.__proto__ === fn.prototype

fn.prototype.constructor === fn // true


// 函数（包括原生构造函数）的原型对象为Function.prototype
fn.__proto__ === Function.prototype // true
Array.__proto__ === Function.prototype // true
Object.__proto__ === Function.prototype // true

Function.prototype也是一个普通对象，所以Function.prototype.__proto__ === Object.prototype



function getProperty(obj, propName) {
    // 在对象本身查找
    if (obj.hasOwnProperty(propName)) {
        return obj[propName]
    } else if (obj.__proto__ !== null) {
    // 如果对象有原型，则在原型上递归查找
        return getProperty(obj.__proto__, propName)
    } else {
    // 直到找到Object.prototype，Object.prototype.__proto__为null，返回undefined
        return undefined
    }
}

Function.__proto__ === Function.prototype
因为Function本身也是一个Function对象
也就是var Function = new Function()，这看起来有点鸡和蛋的意思，不过如果先给你一个蛋，那必然就是先有蛋后有鸡了





2、原型链
当访问一个对象的属性时，先在对象的本身找，找不到就去对象的原型上找，如果还是找不到，就去对象的原型（原型也是对象，也有它自己的原型）的原型上找，如此继续，直到找到为止，或者查找到最顶层的原型对象中也没有找到，就结束查找，返回undefined。
这条由对象及其原型组成的链就叫做原型链


原型存在的意义就是组成原型链
原型链存在的意义就是继承
继承存在的意义就是属性共享

__proto__属性虽然在ECMAScript 6语言规范中标准化，但是不推荐被使用，现在更推荐使用Object.getPrototypeOf，Object.getPrototypeOf(obj)也可以获取到obj对象的原型。本文中使用__proto__只是为了便于理解。

